'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var schemaUtils = require('schema-utils');
var webpack = require('webpack');
var sitemap = require('sitemap');
var util = require('util');
var webpackSources = require('webpack-sources');
var zlib = require('zlib');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var webpackSources__default = /*#__PURE__*/_interopDefaultLegacy(webpackSources);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

// Webpack 4/5 compat
// https://github.com/webpack/webpack/issues/11425#issuecomment-686607633
// istanbul ignore next
var RawSource = (webpack.sources || webpackSources__default['default']).RawSource;
var gzip = util.promisify(zlib.gzip);
// Assertion function to ensure that a string is a valid changefreq.
function assertValidChangefreq(changefreq) {
    if (!sitemap.isValidChangeFreq(changefreq)) {
        throw new Error("Invalid changefreq option: " + changefreq);
    }
}
// Helper function to determine the publicPath from the compilation.
function compilationPublicPath(compilation) {
    if (compilation.options.output &&
        compilation.options.output.publicPath &&
        compilation.options.output.publicPath !== "auto") {
        return compilation.options.output.publicPath.replace(/\/$/, "");
    }
    else {
        return "";
    }
}
// Helper function to emit an asset to a compilation through either the old or new API.
function compilationEmitAsset(compilation, file, source) {
    if (compilation.emitAsset) {
        compilation.emitAsset(file, source);
    }
    else {
        compilation.assets[file] = source;
    }
}
// Helper to return an object of attributes combining path and global options.
function pathAttributes(path, globalOptions) {
    if (typeof path === "string") {
        path = { path: path };
    }
    var url = path.path, changefreq = path.changefreq, rest = __rest(path, ["path", "changefreq"]);
    var pathAttributes = __assign(__assign(__assign({}, globalOptions), rest), { url: url });
    if (changefreq) {
        assertValidChangefreq(changefreq);
        pathAttributes.changefreq = changefreq;
    }
    return pathAttributes;
}
// Helper function to return the correct filename for a sitemap asset.
function sitemapFilename(filename, extension, index) {
    if (index === 0) {
        return filename + "." + extension;
    }
    else {
        return filename + "-" + index + "." + extension;
    }
}
// Helper function to convert a stream from the sitemap library into a string
// that can be emitted by webpack.
function sitemapStreamToString(stream, formatter) {
    var str = "";
    return new Promise(function (resolve) {
        stream.on("data", function (data) {
            str += data.toString();
        });
        stream.on("end", function () {
            if (formatter) {
                str = formatter(str);
            }
            resolve(str);
        });
    });
}

// Generate a single sitemap as a string.
function generateSitemap(paths, base, globalPathOptions, formatter) {
    return __awaiter(this, void 0, void 0, function () {
        var sitemap$1;
        return __generator(this, function (_a) {
            sitemap$1 = new sitemap.SitemapStream({ hostname: base });
            paths.forEach(function (path) {
                sitemap$1.write(pathAttributes(path, globalPathOptions));
            });
            sitemap$1.end();
            return [2 /*return*/, sitemapStreamToString(sitemap$1, formatter)];
        });
    });
}
// Depending on the number of paths provided, generate either a single sitemap
// or multiple sitemaps with an index file.
function generateSitemaps(paths, base, publicPath, filename, skipgzip, globalPathOptions, formatter) {
    return __awaiter(this, void 0, void 0, function () {
        var sitemap$1, sitemaps, indexExt, sitemapIndex, index, i, sitemap$1, sitemapIndexStr;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (base.substr(-1) === "/") {
                        base = base.replace(/\/$/, "");
                    }
                    if (!(paths.length <= 50000)) return [3 /*break*/, 2];
                    return [4 /*yield*/, generateSitemap(paths, base, globalPathOptions, formatter)];
                case 1:
                    sitemap$1 = _a.sent();
                    return [2 /*return*/, [sitemap$1]];
                case 2:
                    sitemaps = [];
                    indexExt = skipgzip ? "xml" : "xml.gz";
                    sitemapIndex = new sitemap.SitemapIndexStream();
                    index = 1;
                    i = 0;
                    _a.label = 3;
                case 3:
                    if (!(i < paths.length)) return [3 /*break*/, 6];
                    return [4 /*yield*/, generateSitemap(paths.slice(i, i + 45000), base, globalPathOptions, formatter)];
                case 4:
                    sitemap$1 = _a.sent();
                    sitemaps.push(sitemap$1);
                    sitemapIndex.write("" + base + publicPath + "/" + sitemapFilename(filename, indexExt, index));
                    index++;
                    _a.label = 5;
                case 5:
                    i += 45000;
                    return [3 /*break*/, 3];
                case 6:
                    sitemapIndex.end();
                    return [4 /*yield*/, sitemapStreamToString(sitemapIndex, formatter)];
                case 7:
                    sitemapIndexStr = _a.sent();
                    sitemaps.unshift(sitemapIndexStr);
                    return [2 /*return*/, sitemaps];
            }
        });
    });
}

var type = "object";
var properties = {
	base: {
		type: "string",
		description: "The fully qualified base domain of your site (e.g. `https://mysite.com`)"
	},
	paths: {
		type: "array",
		items: {
			anyOf: [
				{
					description: "The relative path to this page, e.g. '/about'",
					type: "string"
				},
				{
					type: "object",
					properties: {
						path: {
							description: "The relative path to this page, e.g. '/about'",
							type: "string"
						},
						changefreq: {
							description: "How frequently the page is likely to change. This value provides general information to search engines and may not correlate exactly to how often they crawl the page.",
							"enum": [
								"always",
								"hourly",
								"daily",
								"weekly",
								"monthly",
								"yearly",
								"never"
							]
						},
						lastmod: {
							description: "The date of last modification of the file. This date should be in W3C Datetime format. This format allows you to omit the time portion, if desired, and use YYYY-MM-DD. If set to `true`, the plugin will use the current timestamp.",
							anyOf: [
								{
									type: "string"
								},
								{
									type: "boolean"
								}
							]
						},
						priority: {
							description: "The priority of this URL relative to other URLs on your site. Valid values range from 0.0 to 1.0.",
							type: "number",
							minimum: 0,
							maximum: 1
						}
					},
					required: [
						"path"
					]
				}
			]
		}
	},
	options: {
		type: "object",
		properties: {
			filename: {
				description: "The name of the sitemap file emitted to your build output.",
				type: "string"
			},
			skipgzip: {
				description: "Whether to skip generating a gzipped sitemap alongside the plain-text file (defaults to `false`).",
				type: "boolean"
			},
			formatter: {
				description: "An optional function to format the generated sitemap before it is emitted (for example, if you'd like to pretty-print the XML).",
				instanceOf: "Function"
			},
			changefreq: {
				description: "How frequently the page is likely to change. This value provides general information to search engines and may not correlate exactly to how often they crawl the page. Can be overridden by path-specific `changefreq` setting.",
				"enum": [
					"always",
					"hourly",
					"daily",
					"weekly",
					"monthly",
					"yearly",
					"never"
				]
			},
			lastmod: {
				description: "The date of last modification of the file. This date should be in W3C Datetime format. This format allows you to omit the time portion, if desired, and use YYYY-MM-DD. If set to `true`, the plugin will use the current timestamp. Can be overridden by path-specific `lastmod` setting.",
				anyOf: [
					{
						type: "string"
					},
					{
						type: "boolean"
					}
				]
			},
			priority: {
				description: "The priority of this URL relative to other URLs on your site. Valid values range from 0.0 to 1.0. Can be overridden by path-specific `priority` setting.",
				type: "number",
				minimum: 0,
				maximum: 1
			}
		}
	}
};
var required = [
	"base",
	"paths"
];
var additionalProperties = false;
var schema = {
	type: type,
	properties: properties,
	required: required,
	additionalProperties: additionalProperties
};

var SitemapWebpackPlugin = /** @class */ (function () {
    function SitemapWebpackPlugin(configuration) {
        this.filename = "sitemap";
        this.skipgzip = false;
        schemaUtils.validate(schema, configuration, {
            name: "SitemapWebpackPlugin"
        });
        var base = configuration.base, paths = configuration.paths, _a = configuration.options, options = _a === void 0 ? {} : _a;
        // Set mandatory values
        this.base = base;
        this.paths = paths;
        var filename = options.filename, skipgzip = options.skipgzip, formatter = options.formatter, lastmod = options.lastmod, changefreq = options.changefreq, rest = __rest(options, ["filename", "skipgzip", "formatter", "lastmod", "changefreq"]);
        if (filename) {
            this.filename = filename.replace(/\.xml$/, "");
        }
        if (skipgzip) {
            this.skipgzip = skipgzip;
        }
        this.formatter = formatter;
        var globalPathOptions = rest;
        if (lastmod) {
            if (typeof lastmod === "string") {
                globalPathOptions.lastmod = lastmod;
            }
            else {
                globalPathOptions.lastmod = new Date().toISOString().split("T")[0];
            }
        }
        if (changefreq) {
            assertValidChangefreq(changefreq);
            globalPathOptions.changefreq = changefreq;
        }
        this.globalPathOptions = globalPathOptions;
    }
    SitemapWebpackPlugin.prototype.emitSitemaps = function (compilation) {
        return __awaiter(this, void 0, void 0, function () {
            var publicPath, sitemaps, err_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        publicPath = compilationPublicPath(compilation);
                        return [4 /*yield*/, generateSitemaps(this.paths, this.base, publicPath, this.filename, this.skipgzip, this.globalPathOptions, this.formatter)];
                    case 1:
                        sitemaps = _a.sent();
                        sitemaps.forEach(function (sitemap, idx) {
                            compilationEmitAsset(compilation, sitemapFilename(_this.filename, "xml", idx), new RawSource(sitemap, false));
                        });
                        return [2 /*return*/, sitemaps];
                    case 2:
                        err_1 = _a.sent();
                        compilation.errors.push(err_1.stack);
                        return [2 /*return*/, []];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    SitemapWebpackPlugin.prototype.emitCompressedSitemaps = function (compilation, sitemaps) {
        return __awaiter(this, void 0, void 0, function () {
            var idx, sitemap, compressed, err_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        idx = 0;
                        _a.label = 1;
                    case 1:
                        if (!(idx < sitemaps.length)) return [3 /*break*/, 6];
                        sitemap = sitemaps[idx];
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, gzip(sitemap)];
                    case 3:
                        compressed = _a.sent();
                        compilationEmitAsset(compilation, sitemapFilename(this.filename, "xml.gz", idx), new RawSource(compressed, false));
                        return [3 /*break*/, 5];
                    case 4:
                        err_2 = _a.sent();
                        compilation.errors.push(err_2.stack);
                        return [3 /*break*/, 5];
                    case 5:
                        idx++;
                        return [3 /*break*/, 1];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    SitemapWebpackPlugin.prototype.run = function (compilation) {
        return __awaiter(this, void 0, void 0, function () {
            var sitemaps;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.emitSitemaps(compilation)];
                    case 1:
                        sitemaps = _a.sent();
                        if (!(this.skipgzip !== true)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.emitCompressedSitemaps(compilation, sitemaps)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    SitemapWebpackPlugin.prototype.apply = function (compiler) {
        var _this = this;
        if (compiler.webpack && compiler.webpack.version[0] == "5") {
            // webpack 5
            compiler.hooks.compilation.tap("sitemap-webpack-plugin", function (compilation) {
                compilation.hooks.processAssets.tapPromise({
                    name: "sitemap-webpack-plugin",
                    stage: webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL
                }, function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                    return [2 /*return*/, this.run(compilation)];
                }); }); });
            });
        }
        else if (compiler.hooks) {
            // webpack 4
            compiler.hooks.emit.tapPromise("sitemap-webpack-plugin", function (compilation) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                return [2 /*return*/, this.run(compilation)];
            }); }); });
        }
        else {
            throw new Error("Unsupported webpack version; must be 4 or 5");
        }
    };
    return SitemapWebpackPlugin;
}());

exports.default = SitemapWebpackPlugin;
